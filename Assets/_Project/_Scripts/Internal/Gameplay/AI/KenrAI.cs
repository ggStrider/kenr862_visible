using System.Collections;
using System.Collections.Generic;
using Cutscenes;
using Internal.Core;
using Internal.Core.Tools;
using Internal.Gameplay.Environment.Rooms;
using Internal.Gameplay.Wtf;
using UnityEngine;
using UnityEngine.AI;
using Zenject;

namespace Internal.Gameplay.AI
{
    // class generated by AI; sorry I DONT HAVE TIME BROTHA
    public class KenrAI : MonoBehaviour
    {
        [SerializeField] private Transform _castVisionRays;
        
        [Space]
        [Header("Navigation")] [SerializeField]
        private NavMeshAgent _agent;

        [SerializeField] private List<Transform> _rooms; // Точки входу в кімнати
        [SerializeField] private Transform _streamerRoom; // Його кімната (точка)
        [SerializeField] private Transform _playerSpawnRoom;

        [Header("Timing")] [SerializeField] private Vector2 _idleTimeRange = new Vector2(3, 6); // Час анімації у кімнаті
        [SerializeField] private Vector2 actionTimeRange;

        [Header("Player Detection")] [SerializeField]
        private Transform _player;

        [SerializeField] private float _viewDistance = 10f;
        [SerializeField] private float _viewAngle = 100f;
        [SerializeField] private LayerMask _obstructionMask;
        
        [Space]
        [SerializeField] private float _catchDistance = 1.2f;
        
        [Space]
        [Header("Animation")] [SerializeField] private Animator _animator;
        [SerializeField] private string _walkAnim = "Walk";
        [SerializeField] private string _idleAnim = "Idle";
        [SerializeField] private string _actionAnim = "Action";
        [SerializeField] private string _runAnim = "Run";


        private Transform _targetRoom;
        private Vector3 _lastSeenPlayerPos;
        private bool _playerInSight;

        private enum State
        {
            Idle,
            MovingToRoom,
            DoingAction,
            Returning,
            Chasing,
            Searching
        }

        [SerializeField] private State _state;

        [Space] [SerializeField] private float _timeToStart = 10f;
        [SerializeField] private float _timeToAccessToPlayerStartRoom = 35f;

        private PlayerRoomManager _playerRoomManager;
        
        public KenrAI()
        {
            actionTimeRange = new Vector2(5, 10);
        }

        [Inject]
        private void Construct(PlayerRoomManager playerRoomManager)
        {
            _playerRoomManager = playerRoomManager;
        }

        private IEnumerator Start()
        {
            StartCoroutine(WaitToStartStateMachine());
            
            yield return new WaitForSeconds(_timeToAccessToPlayerStartRoom);
            _rooms.Add(_playerSpawnRoom);
        }

        private IEnumerator WaitToStartStateMachine()
        {
            yield return new WaitForSeconds(_timeToStart);
            if (_agent == null) _agent = GetComponent<NavMeshAgent>();
            _state = State.Idle;
            StartCoroutine(StateMachine());
        }

        private void Update()
        {
            DetectPlayer();
        }

        private IEnumerator StateMachine()
        {
            while (true)
            {
                switch (_state)
                {
                    case State.Idle:
                        ResetLocalTransform();
                        _animator.Play(_idleAnim);
                        yield return new WaitForSeconds(Random.Range(_idleTimeRange.x, _idleTimeRange.y));
                        ChooseRandomRoom();
                        _state = State.MovingToRoom;
                        break;

                    case State.MovingToRoom:
                        _animator.Play(_walkAnim);
                        _agent.SetDestination(_targetRoom.position);
                        yield return new WaitUntil(() =>
                            !_agent.pathPending && _agent.remainingDistance <= _agent.stoppingDistance);
                        _state = State.DoingAction;
                        break;

                    case State.DoingAction:
                        _animator.Play(_actionAnim);
                        yield return new WaitForSeconds(Random.Range(actionTimeRange.x, actionTimeRange.y));
                        _state = State.Returning;
                        break;

                    case State.Returning:
                        _animator.Play(_walkAnim);
                        _agent.SetDestination(_streamerRoom.position);
                        yield return new WaitUntil(() =>
                            !_agent.pathPending && _agent.remainingDistance <= _agent.stoppingDistance);
                        _animator.Play(_actionAnim); // своя анімація у кімнаті стрімів
                        yield return new WaitForSeconds(Random.Range(_idleTimeRange.x, _idleTimeRange.y));
                        _state = State.Idle;
                        break;

                    case State.Chasing:
                        _animator.Play(_runAnim);
                        _agent.SetDestination(_player.position);

                        float distanceToPlayer = Vector3.Distance(transform.position, _player.position);
                        if (distanceToPlayer <= _catchDistance)
                        {
                            OnCatchPlayer();
                            // можна зупинити стан:
                            _state = State.Idle; 
                            _agent.ResetPath();
                        }

                        yield return null;
                        break;

                    case State.Searching:
                        _animator.Play(_walkAnim);
                        _agent.SetDestination(_lastSeenPlayerPos);
                        yield return new WaitUntil(() =>
                            !_agent.pathPending && _agent.remainingDistance <= _agent.stoppingDistance);
                        yield return new WaitForSeconds(3f);
                        _state = State.Idle;
                        break;
                }
                
                yield return null;
            }
        }

        private bool _playerCaught;
        [SerializeField, Range(0f, 1f)] private float _chanceToHaveDelayedScreamer = 0.1f;
        [SerializeField] private float _minDelayToScreamer = 2.2f;
        [SerializeField] private float _maxDelayToScreamer = 3.6f;
        
        private void OnCatchPlayer()
        {
            if(_playerCaught) return;
            _playerCaught = true;

            var screamerController = FindAnyObjectByType<ScreamerController>();
            if (_chanceToHaveDelayedScreamer >= Random.value)
            {
                var delay = Random.Range(_minDelayToScreamer, _maxDelayToScreamer);
                CooldownRunner.Run(delay, () => screamerController.PlayScreamer(transform));
            }
            else
            { 
                screamerController.PlayScreamer(transform);
            }

            gameObject.SetActive(false);
            // awh hell nawh
        }
        
        private void ResetLocalTransform()
        {
            _animator.transform.localPosition = Vector3.zero;
            _animator.transform.localRotation = Quaternion.identity;
        }

        [SerializeField, Range(0f, 1f)] private float _chanceToGoInRoomWherePlayer = 0.2f;
        private Transform _previousRoom;
        private void ChooseRandomRoom()
        {
            // rooms is List
            if (_rooms.Count == 0) return;

            if (_chanceToGoInRoomWherePlayer >= Random.value 
                && _playerRoomManager.RoomWherePlayerNow.KenrWaypoint != null)
            {
                var possibleRoom = _playerRoomManager.RoomWherePlayerNow.KenrWaypoint;
                if (_rooms.Contains(possibleRoom) || possibleRoom == _previousRoom)
                {
                    _targetRoom = _playerRoomManager.RoomWherePlayerNow.KenrWaypoint;
                }
                else
                {
                    GetRandomRoom();
                }
            }
            else
            {
                GetRandomRoom();
            }
        }

        private void GetRandomRoom()
        {
            int index = Random.Range(0, _rooms.Count);
            _targetRoom = _rooms[index];
            
            if (_previousRoom != null)
            {
                _rooms.Add(_previousRoom);
            }
            _previousRoom = _targetRoom;
            _rooms.Remove(_targetRoom);
        }

        [SerializeField] private float _distanceToCheckIfNear = 1.5f;
        
        private void DetectPlayer()
        {
            Vector3 dirToPlayer = (_player.position - _castVisionRays.position).normalized;
            float dist = Vector3.Distance(_castVisionRays.position, _player.position);

            bool playerDetected = false;

            // --- Якщо гравець у полі зору ---
            if (dist <= _viewDistance)
            {
                float angle = Vector3.Angle(_castVisionRays.forward, dirToPlayer);
                if (angle < _viewAngle / 2f)
                {
                    if (!Physics.Raycast(_castVisionRays.position, dirToPlayer, dist, _obstructionMask))
                        playerDetected = true;
                }
            }

            // --- Якщо дуже близько (навіть позаду) ---
            if (!playerDetected && dist <= _distanceToCheckIfNear)
            {
                if (!Physics.Raycast(_castVisionRays.position, dirToPlayer, dist, _obstructionMask))
                    playerDetected = true;
            }

            if (playerDetected)
            {
                if (_state != State.Chasing)
                {
                    StopAllCoroutines();
                    _state = State.Chasing;
                    StartCoroutine(StateMachine());
                }

                _playerInSight = true;
                _lastSeenPlayerPos = _player.position;
            }
            else if (_playerInSight)
            {
                _playerInSight = false;
                _state = State.Searching;
            }
        }
        
#if UNITY_EDITOR
        private void OnDrawGizmosSelected()
        {
            // --- View Distance ---
            Gizmos.color = Color.yellow;
            Gizmos.DrawWireSphere(_castVisionRays.position, _viewDistance);

            // --- Near Check Distance ---
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(_castVisionRays.position, _distanceToCheckIfNear);

            // --- View Angle ---
            Vector3 forward = transform.forward;
            Vector3 leftBoundary = Quaternion.Euler(0, -_viewAngle / 2f, 0) * forward;
            Vector3 rightBoundary = Quaternion.Euler(0, _viewAngle / 2f, 0) * forward;

            Gizmos.color = new Color(1f, 1f, 0f, 0.2f);
            Gizmos.DrawLine(_castVisionRays.position, _castVisionRays.position + leftBoundary * _viewDistance);
            Gizmos.DrawLine(_castVisionRays.position, _castVisionRays.position + rightBoundary * _viewDistance);
        }
#endif

    }
}